import asyncio, orjson, time, logging
import websockets
from websockets.client import WebSocketClientProtocol
from typing import List, Dict, Any, Optional
from .metrics import ws_connects, ws_reconnects, ws_errors, events_ingested

SUB_TPL = {
    "ticker": {"action": "subscribe", "channels": [{"name": "ticker", "markets": []}]},
    "trade":  {"action": "subscribe", "channels": [{"name": "trades", "markets": []}]},
    "book":   {"action": "subscribe", "channels": [{"name": "book", "markets": []}]},
}

class WSClient:
    def __init__(self, url: str, max_retries: int = 3, backoff_ms: int = 750):
        self.url = url
        self.max_retries = max_retries
        self.backoff_ms = backoff_ms
        self.ws: Optional[WebSocketClientProtocol] = None

    async def connect(self):
        ws_connects.inc()
        self.ws = await websockets.connect(self.url, ping_interval=20, ping_timeout=20, close_timeout=5)

    async def close(self):
        if self.ws:
            await self.ws.close()
            self.ws = None

    async def subscribe(self, channels: Dict[str, List[str]]):
        # channels: {"ticker": [...], "trade": [...], "book": [...]}
        for ch, markets in channels.items():
            if not markets: 
                continue
            msg = SUB_TPL[ch].copy()
            msg["channels"] = [{"name": SUB_TPL[ch]["channels"][0]["name"], "markets": markets}]
            await self.ws.send(orjson.dumps(msg).decode())
            await asyncio.sleep(0.05)

    async def run(self, channels: Dict[str, List[str]], handlers: Dict[str, Any]):
        attempt = 0
        while True:
            try:
                await self.connect()
                await self.subscribe(channels)
                async for raw in self.ws:
                    # NOTE: classification per project WS-contract
                    evname = evt.get("event")
                    ch = None
                    if evname in ("ticker","ticker24h") or ("market" in evt and ("lastPrice" in evt or "bid" in evt) and evname is None):
                        ch = "ticker"
                    elif evname in ("trades","trade") or ("market" in evt and "amount" in evt and "price" in evt and "side" in evt):
                        ch = "trade"
                    elif evname == "book" or ("market" in evt and ("bids" in evt or "asks" in evt)):
                        ch = "book"
                    try:
                        evt = orjson.loads(raw)
                    except Exception as e:
                        ws_errors.labels("decode").inc()
                        continue
                    # naive channel detect based on payload shape
                    name = evt.get("event") or evt.get("action") or evt.get("type")
                    # bitvavo public events often include keys per channel; fallback mapping:
                    ch = None
                    if "market" in evt and "price" in evt and "volume" in evt and "high" in evt:
                        ch = "ticker"
                    elif "market" in evt and "amount" in evt and "price" in evt and "side" in evt:
                        ch = "trade"
                    elif "market" in evt and ("bids" in evt or "asks" in evt):
                        ch = "book"
                    if ch and ch in handlers:
                        await handlers[ch](evt)
                        events_ingested.labels(ch).inc()
            except Exception as e:
                ws_errors.labels("loop").inc()
                attempt += 1
                if attempt > self.max_retries:
                    logging.exception("WS failed permanently")
                    await asyncio.sleep(2.0)
                    attempt = 0
                else:
                    ws_reconnects.inc()
                    await asyncio.sleep(self.backoff_ms/1000 * attempt)
            finally:
                await self.close()
